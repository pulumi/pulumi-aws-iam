// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package awsiam

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws-iam/sdk/go/aws-iam/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource helps you create an IAM Group with Users who are allowed to assume specified
// IAM roles.
//
// ## Example Usage
// ## Group With Assumable Roles Policy
//
// ```go
// package main
//
// import (
//
//	iam "github.com/pulumi/pulumi-aws-iam/sdk/go/aws-iam"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//	    pulumi.Run(func(ctx *pulumi.Context) error {
//	        groupWithAssumableRolesPolicy, err := iam.NewGroupWithAssumableRolesPolicy(ctx, "group-with-assumable-roles-policy", &iam.GroupWithAssumableRolesPolicyArgs{
//	            Name:           pulumi.String("production-readonly"),
//	            AssumableRoles: pulumi.ToStringArray([]string{"arn:aws:iam::835367859855:role/readonly"}),
//	            GroupUsers:     pulumi.ToStringArray([]string{"user1", "user2"}),
//	        })
//	        if err != nil {
//	            return err
//	        }
//
//	        ctx.Export("groupWithAssumableRolesPolicy", groupWithAssumableRolesPolicy)
//
//	        return nil
//	    })
//	}
//
// ```
// {{ /example }}
type GroupWithAssumableRolesPolicy struct {
	pulumi.ResourceState

	// List of IAM roles ARNs which can be assumed by the group
	AssumableRoles pulumi.StringArrayOutput `pulumi:"assumableRoles"`
	// IAM group arn.
	GroupArn pulumi.StringOutput `pulumi:"groupArn"`
	// IAM group name.
	GroupName pulumi.StringOutput `pulumi:"groupName"`
	// List of IAM users in IAM group
	GroupUsers pulumi.StringArrayOutput `pulumi:"groupUsers"`
	// Assume role policy ARN of IAM group
	PolicyArn pulumi.StringOutput `pulumi:"policyArn"`
}

// NewGroupWithAssumableRolesPolicy registers a new resource with the given unique name, arguments, and options.
func NewGroupWithAssumableRolesPolicy(ctx *pulumi.Context,
	name string, args *GroupWithAssumableRolesPolicyArgs, opts ...pulumi.ResourceOption) (*GroupWithAssumableRolesPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AssumableRoles == nil {
		return nil, errors.New("invalid value for required argument 'AssumableRoles'")
	}
	if args.GroupUsers == nil {
		return nil, errors.New("invalid value for required argument 'GroupUsers'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource GroupWithAssumableRolesPolicy
	err := ctx.RegisterRemoteComponentResource("aws-iam:index:GroupWithAssumableRolesPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type groupWithAssumableRolesPolicyArgs struct {
	// List of IAM roles ARNs which can be assumed by the group
	AssumableRoles []string `pulumi:"assumableRoles"`
	// List of IAM users to have in an IAM group which can assume the role
	GroupUsers []string `pulumi:"groupUsers"`
	// Name of IAM policy and IAM group.
	Name string `pulumi:"name"`
	// A map of tags to add.
	Tags map[string]string `pulumi:"tags"`
}

// The set of arguments for constructing a GroupWithAssumableRolesPolicy resource.
type GroupWithAssumableRolesPolicyArgs struct {
	// List of IAM roles ARNs which can be assumed by the group
	AssumableRoles pulumi.StringArrayInput
	// List of IAM users to have in an IAM group which can assume the role
	GroupUsers pulumi.StringArrayInput
	// Name of IAM policy and IAM group.
	Name pulumi.StringInput
	// A map of tags to add.
	Tags pulumi.StringMapInput
}

func (GroupWithAssumableRolesPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*groupWithAssumableRolesPolicyArgs)(nil)).Elem()
}

type GroupWithAssumableRolesPolicyInput interface {
	pulumi.Input

	ToGroupWithAssumableRolesPolicyOutput() GroupWithAssumableRolesPolicyOutput
	ToGroupWithAssumableRolesPolicyOutputWithContext(ctx context.Context) GroupWithAssumableRolesPolicyOutput
}

func (*GroupWithAssumableRolesPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupWithAssumableRolesPolicy)(nil)).Elem()
}

func (i *GroupWithAssumableRolesPolicy) ToGroupWithAssumableRolesPolicyOutput() GroupWithAssumableRolesPolicyOutput {
	return i.ToGroupWithAssumableRolesPolicyOutputWithContext(context.Background())
}

func (i *GroupWithAssumableRolesPolicy) ToGroupWithAssumableRolesPolicyOutputWithContext(ctx context.Context) GroupWithAssumableRolesPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupWithAssumableRolesPolicyOutput)
}

// GroupWithAssumableRolesPolicyArrayInput is an input type that accepts GroupWithAssumableRolesPolicyArray and GroupWithAssumableRolesPolicyArrayOutput values.
// You can construct a concrete instance of `GroupWithAssumableRolesPolicyArrayInput` via:
//
//	GroupWithAssumableRolesPolicyArray{ GroupWithAssumableRolesPolicyArgs{...} }
type GroupWithAssumableRolesPolicyArrayInput interface {
	pulumi.Input

	ToGroupWithAssumableRolesPolicyArrayOutput() GroupWithAssumableRolesPolicyArrayOutput
	ToGroupWithAssumableRolesPolicyArrayOutputWithContext(context.Context) GroupWithAssumableRolesPolicyArrayOutput
}

type GroupWithAssumableRolesPolicyArray []GroupWithAssumableRolesPolicyInput

func (GroupWithAssumableRolesPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GroupWithAssumableRolesPolicy)(nil)).Elem()
}

func (i GroupWithAssumableRolesPolicyArray) ToGroupWithAssumableRolesPolicyArrayOutput() GroupWithAssumableRolesPolicyArrayOutput {
	return i.ToGroupWithAssumableRolesPolicyArrayOutputWithContext(context.Background())
}

func (i GroupWithAssumableRolesPolicyArray) ToGroupWithAssumableRolesPolicyArrayOutputWithContext(ctx context.Context) GroupWithAssumableRolesPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupWithAssumableRolesPolicyArrayOutput)
}

// GroupWithAssumableRolesPolicyMapInput is an input type that accepts GroupWithAssumableRolesPolicyMap and GroupWithAssumableRolesPolicyMapOutput values.
// You can construct a concrete instance of `GroupWithAssumableRolesPolicyMapInput` via:
//
//	GroupWithAssumableRolesPolicyMap{ "key": GroupWithAssumableRolesPolicyArgs{...} }
type GroupWithAssumableRolesPolicyMapInput interface {
	pulumi.Input

	ToGroupWithAssumableRolesPolicyMapOutput() GroupWithAssumableRolesPolicyMapOutput
	ToGroupWithAssumableRolesPolicyMapOutputWithContext(context.Context) GroupWithAssumableRolesPolicyMapOutput
}

type GroupWithAssumableRolesPolicyMap map[string]GroupWithAssumableRolesPolicyInput

func (GroupWithAssumableRolesPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GroupWithAssumableRolesPolicy)(nil)).Elem()
}

func (i GroupWithAssumableRolesPolicyMap) ToGroupWithAssumableRolesPolicyMapOutput() GroupWithAssumableRolesPolicyMapOutput {
	return i.ToGroupWithAssumableRolesPolicyMapOutputWithContext(context.Background())
}

func (i GroupWithAssumableRolesPolicyMap) ToGroupWithAssumableRolesPolicyMapOutputWithContext(ctx context.Context) GroupWithAssumableRolesPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupWithAssumableRolesPolicyMapOutput)
}

type GroupWithAssumableRolesPolicyOutput struct{ *pulumi.OutputState }

func (GroupWithAssumableRolesPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupWithAssumableRolesPolicy)(nil)).Elem()
}

func (o GroupWithAssumableRolesPolicyOutput) ToGroupWithAssumableRolesPolicyOutput() GroupWithAssumableRolesPolicyOutput {
	return o
}

func (o GroupWithAssumableRolesPolicyOutput) ToGroupWithAssumableRolesPolicyOutputWithContext(ctx context.Context) GroupWithAssumableRolesPolicyOutput {
	return o
}

// List of IAM roles ARNs which can be assumed by the group
func (o GroupWithAssumableRolesPolicyOutput) AssumableRoles() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GroupWithAssumableRolesPolicy) pulumi.StringArrayOutput { return v.AssumableRoles }).(pulumi.StringArrayOutput)
}

// IAM group arn.
func (o GroupWithAssumableRolesPolicyOutput) GroupArn() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupWithAssumableRolesPolicy) pulumi.StringOutput { return v.GroupArn }).(pulumi.StringOutput)
}

// IAM group name.
func (o GroupWithAssumableRolesPolicyOutput) GroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupWithAssumableRolesPolicy) pulumi.StringOutput { return v.GroupName }).(pulumi.StringOutput)
}

// List of IAM users in IAM group
func (o GroupWithAssumableRolesPolicyOutput) GroupUsers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GroupWithAssumableRolesPolicy) pulumi.StringArrayOutput { return v.GroupUsers }).(pulumi.StringArrayOutput)
}

// Assume role policy ARN of IAM group
func (o GroupWithAssumableRolesPolicyOutput) PolicyArn() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupWithAssumableRolesPolicy) pulumi.StringOutput { return v.PolicyArn }).(pulumi.StringOutput)
}

type GroupWithAssumableRolesPolicyArrayOutput struct{ *pulumi.OutputState }

func (GroupWithAssumableRolesPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GroupWithAssumableRolesPolicy)(nil)).Elem()
}

func (o GroupWithAssumableRolesPolicyArrayOutput) ToGroupWithAssumableRolesPolicyArrayOutput() GroupWithAssumableRolesPolicyArrayOutput {
	return o
}

func (o GroupWithAssumableRolesPolicyArrayOutput) ToGroupWithAssumableRolesPolicyArrayOutputWithContext(ctx context.Context) GroupWithAssumableRolesPolicyArrayOutput {
	return o
}

func (o GroupWithAssumableRolesPolicyArrayOutput) Index(i pulumi.IntInput) GroupWithAssumableRolesPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GroupWithAssumableRolesPolicy {
		return vs[0].([]*GroupWithAssumableRolesPolicy)[vs[1].(int)]
	}).(GroupWithAssumableRolesPolicyOutput)
}

type GroupWithAssumableRolesPolicyMapOutput struct{ *pulumi.OutputState }

func (GroupWithAssumableRolesPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GroupWithAssumableRolesPolicy)(nil)).Elem()
}

func (o GroupWithAssumableRolesPolicyMapOutput) ToGroupWithAssumableRolesPolicyMapOutput() GroupWithAssumableRolesPolicyMapOutput {
	return o
}

func (o GroupWithAssumableRolesPolicyMapOutput) ToGroupWithAssumableRolesPolicyMapOutputWithContext(ctx context.Context) GroupWithAssumableRolesPolicyMapOutput {
	return o
}

func (o GroupWithAssumableRolesPolicyMapOutput) MapIndex(k pulumi.StringInput) GroupWithAssumableRolesPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GroupWithAssumableRolesPolicy {
		return vs[0].(map[string]*GroupWithAssumableRolesPolicy)[vs[1].(string)]
	}).(GroupWithAssumableRolesPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GroupWithAssumableRolesPolicyInput)(nil)).Elem(), &GroupWithAssumableRolesPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupWithAssumableRolesPolicyArrayInput)(nil)).Elem(), GroupWithAssumableRolesPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupWithAssumableRolesPolicyMapInput)(nil)).Elem(), GroupWithAssumableRolesPolicyMap{})
	pulumi.RegisterOutputType(GroupWithAssumableRolesPolicyOutput{})
	pulumi.RegisterOutputType(GroupWithAssumableRolesPolicyArrayOutput{})
	pulumi.RegisterOutputType(GroupWithAssumableRolesPolicyMapOutput{})
}
